#
```
ubernetes 微服務實戰 
Hands-On Microservices with Kubernetes
Gigi Sayfan 史天 張媛 樓煒 肖力 譯
機械工業
2020-06-01

https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python
```
```
第1章 面向開發人員的Kubernetes簡介 1
1.1 技術需求 1
1.1.1 安裝Docker 1
1.1.2 安裝kubectl 2
1.1.3 安裝Minikube 2
1.1.4 本章代碼 2
1.2 Kubernetes簡介 2
1.2.1 容器編排平台 2
1.2.2 Kubernetes發展歷史 2
1.2.3 Kubernetes現狀 3
1.3 Kubernetes架構 3
1.3.1 控制平面 4
1.3.2 數據平面 5
1.4 微服務的 搭檔 6
1.4.1 微服務打包和部署 6
1.4.2 微服務公開和發現 8
1.4.3 微服務安全 9
1.4.4 微服務驗證和授權 11
1.4.5 微服務升級 12
1.5 創建本地集群 14
1.5.1 安裝Minikube 14
1.5.2 探索集群 16
1.5.3 安裝Helm 17
1.6 小結 19
1.7 擴展閱讀 19

第2章 微服務入門 20
2.1 技術需求 21
2.1.1 在macOS上通過Homebrew安裝Go 21
2.1.2 在其他平台上安裝Go 21
2.1.3 本章代碼 21
2.2 微服務編程—少即是多 21
2.3 微服務自治 23
2.4 使用接口和契約 23
2.5 通過API公開服務 24
2.6 使用客戶端庫 24
2.7 管理依賴 25
2.8 協調微服務 25
2.9 利用所有權 26
2.10 理解康威定律 27
2.10.1 垂直組織 27
2.10.2 水平組織 28
2.10.3 矩陣組織 28
2.11 跨服務故障排除 28
2.12 利用共享服務庫 29
2.13 選擇源代碼控制策略 29
2.13.1 單體倉庫 29
2.13.2 多倉庫 30
2.13.3 混合模式 30
2.14 選擇數據策略 30
2.14.1 每個微服務對應一個數據存儲 31
2.14.2 運行分佈式查詢 31
2.14.3 使用Saga模式管理跨服務事務 33
2.15 小結 35
2.16 擴展閱讀 36

第3章 示例應用程序—Delinkcious 37
3.1 技術需求 37
3.1.1 Visual Studio Code 38
3.1.2 GoLand 38
3.1.3 LiteIDE 38
3.1.4 其他選項 38
3.1.5 本章代碼 38
3.2 為什麼選擇Go 39
3.3 認識Go kit 39
3.3.1 使用Go kit構建微服務 40
3.3.2 理解傳輸 41
3.3.3 理解端點 41
3.3.4 理解服務 42
3.3.5 理解中間件 42
3.3.6 理解客戶端 43
3.3.7 生成樣板 43
3.4 Delinkcious目錄結構 43
3.4.1 cmd子目錄 44
3.4.2 pkg子目錄 44
3.4.3 svc子目錄 45
3.5 Delinkcious微服務 45
3.5.1 對像模型 46
3.5.2 服務實現 47
3.5.3 支持函數實現 50
3.5.4 通過客戶端庫調用API 53
3.6 數據存儲 56
3.7 小結 58
3.8 擴展閱讀 58

第4章 構建CI/CD流水線 59
4.1 技術需求 59
4.2 理解CI/CD流水線 60
4.3 選擇CI/CD流水線工具 61
4.4.1 Jenkins X 61
4.4.2 Spinnaker 62
4.4.3 Travis CI和CircleCI 62
4.4.4 Tekton 62
4.4.5 Argo CD 63
4.4.6 自研工具 63
4.4 GitOps 63
4.5 使用CircleCI構建鏡像 64
4.5.1 查看源代碼樹 64
4.5.2 配置CI流水線 65
4.5.3 理解構建腳本 66
4.5.4 使用多階段Dockerfile對Go服務容器化 68
4.5.5 探索CircleCI界面 68
4.5.6 未來的改進 71
4.6 為Delinkcious設置持續交付 71
4.6.1 部署Delinkcious微服務 71
4.6.2 理解Argo CD 72
4.6.3 Argo CD入門 73
4.6.4 配置Argo CD 75
4.6.5 探索Argo CD 77
4.7 小結 80
4.8 擴展閱讀 81

第5章 使用Kubernetes配置微服務 82
5.1 技術需求 82
5.2 配置包含的內容 83
5.3 通過傳統方式管理配置 83
5.3.1 約定 84
5.3.2 命令行標誌 85
5.3.3 環境變量 85
5.3.4 配置文件 86
5.3.5 混合配置和默認 90
5.3.6 12-Factor應用程序配置 91
5.4 動態管理配置 92
5.4.1 理解動態配置 92
5.4.2 遠程配置存儲 93
5.4.3 遠程配置服務 93
5.5 使用Kubernetes配置微服務 93
5.5.1 使用Kubernetes ConfigMaps 94
5.5.2 Kubernetes自定義資源 102
5.5.3 服務發現 105
5.6 小結 105
5.7 擴展閱讀 106

第6章 Kubernetes與微服務安全 107
6.1 技術需求 107
6.2 應用完善的安全原則 108
6.3 區分用戶賬戶和服務賬戶 110
6.3.1 用戶賬戶 110
6.3.2 服務賬戶 111
6.4 使用Kubernetes管理密鑰 114
6.4.1 Kubernetes密鑰的三種類型 114
6.4.2 創造自己的密鑰 115
6.4.3 將密鑰傳遞到容器 116
6.4.4 構建一個安全的Pod 117
6.5 使用RBAC管理權限 118
6.6 通過認證、授權和准入控制訪問權限 121
6.6.1 認證 121
6.6.2 授權 125
6.6.3 准入 125
6.7 通過安全 佳實踐增強Kubernetes 126
6.7.1 鏡像安全 126
6.7.2 網絡安全—分而治之 127
6.7.3 鏡像倉庫安全 129
6.7.4 按需授予訪問權限 129
6.7.5 使用配額 小化 半徑 130
6.7.6 實施安全上下文 132
6.7.7 使用安全策略強化Pod 133
6.7.8 強化工具鏈 134
6.8 小結 135
6.9 擴展閱讀 136

第7章 API與負載均衡器 137
7.1 技術需求 137
7.2 熟悉Kubernetes服務 138
7.3 東西流量與南北流量 140
7.4 理解ingress和負載均衡器 141
7.5 提供和使用公有REST API 141
7.5.1 構建基於Python的API網關服務 141
7.5.2 添加ingress 146
7.5.3 驗證API網關 147
7.6 提供和使用內部gRPC API 150
7.6.1 定義NewsManager接口 150
7.6.2 實現消息管理器 151
7.6.3 將NewsManager公開為gRPC服務 153
7.7 通過消息隊列發送和接收事件 158
7.7.1 NATS 159
7.7.2 在Kubernetes集群中部署NATS 159
7.7.3 使用NATS發送鏈接事件 160
7.7.4 訂閱NATS鏈接事件 162
7.7.5 處理鏈接事件 164
7.8 服務網格 166
7.9 小結 166
7.10 擴展閱讀 166

第8章 有狀態服務 167
8.1 技術需求 167
8.2 抽象存儲 168
8.2.1 Kubernetes存儲模型 168
8.2.2 內置和外部存儲插件 172
8.2.3 理解CSI 173
8.3 在Kubernetes集群外存儲數據 174
8.4 使用StatefulSet在Kubernetes集群內存儲數據 175
8.4.1 理解StatefulSet 175
8.4.2 什麼時候應該使用StatefulSet 178
8.4.3 一個大型StatefulSet示例 179
8.5 通過本地存儲實現高性能 183
8.5.1 將數據存儲在內存中 183
8.5.2 將數據存儲在本地SSD硬盤上 183
8.6 在Kubernetes中使用關係型數據庫 183
8.6.1 了解數據的存儲位置 184
8.6.2 使用部署和服務 184
8.6.3 使用StatefulSet 185
8.6.4 幫助用戶服務找到StatefulSet Pod 185
8.6.5 管理模式 改 187
8.7 在Kubernetes中使用非關係型數據存儲 187
8.8 小結 191
8.9 擴展閱讀 192

第9章 在Kubernetes上運行Serverless任務 193
9.1 技術需求 193
9.2 雲中的Serverless 194
9.2.1 微服務與Serverless函數 195
9.2.2 在Kubernetes上的Serverless函數模型 195
9.2.3 構建、配置和部署Serverless函數 196
9.2.4 調用Serverless函數 196
9.3 Delinkcious鏈接檢查 196
9.3.1 設計鏈接檢查 197
9.3.2 實現鏈接檢查 199
9.4 使用Nuclio實現Serverless鏈接檢查 202
9.4.1 Nuclio簡介 202
9.4.2 創建一個鏈接檢查Serverless函數 203
9.4.3 使用nuctl部署鏈接檢查函數 206
9.4.4 使用Nuclio儀表板部署函數 207
9.4.5 直接調用鏈接檢查函數 207
9.4.6 在LinkManager中觸發鏈接檢查 208
9.5 其他Kubernetes Serverless框架 209
9.5.1 Kubernetes Job和CronJob 210
9.5.2 KNative 210
9.5.3 Fission 211
9.5.4 Kubeless 211
9.5.5 OpenFaas 211
9.6 小結 212
9.7 擴展閱讀 212

10章 微服務測試 213
10.1 技術需求 214
10.2 單元測試 214
10.2.1 使用Go進行單元測試 214
10.2.2 使用Ginkgo和Gomega進行單元測試 216
10.2.3 Delinkcious單元測試 217
10.2.4 模擬的藝術 217
10.2.5 你應該測試一切嗎 221
10.3 集成測試 222
10.3.1 初始化測試數據庫 222
10.3.2 運行服務 223
10.3.3 運行實際測試 223
10.3.4 實現數據庫測試輔助函數 225
10.3.5 實現服務測試輔助函數 227
10.4 使用Kubernetes進行本地測試 229
10.4.1 編寫冒煙測試 229
10.4.2 Telepresence 232
10.5 隔離測試 235
10.5.1 隔離集群 236
10.5.2 隔離命名空間 236
10.5.3 跨集群/命名空間 237
10.6 端到端測試 237
10.6.1 驗收測試 237
10.6.2 回歸測試 238
10.6.3 性能測試 238
10.7 管理測試數據 239
10.7.1 合成數據 239
10.7.2 人工測試數據 239
10.7.3 生產環境快照 239
10.8 小結 240
10.9 擴展閱讀 240

11章 微服務部署 241
11.1 技術需求 241
11.2 Kubernetes部署 242
11.3 多環境部署 243
11.4 理解部署策略 246
11.4.1 重新部署 247
11.4.2 滾動 新 247
11.4.3 藍綠部署 248
11.4.4 金絲雀部署 255
11.5 回滾部署 260
11.5.1 回滾標準部署 260
11.5.2 回滾藍綠部署 261
11.5.3 回滾金絲雀部署 262
11.5.4 回滾模式、API或負載的 改 262
11.6 管理版本和依賴 263
11.6.1 管理公有API接口 263
11.6.2 管理跨服務依賴 264
11.6.3 管理第三方依賴 264
11.6.4 管理基礎設施和工具鏈 265
11.7 本地開發部署 265
11.7.1 Ko 266
11.7.2 Ksync 269
11.7.3 Draft 271
11.7.4 Skaffold 272
11.7.5 Tilt 273
11.8 小結 279
11.9 擴展閱讀 279

12章 監控、日誌和指標 280
12.1 技術需求 281
12.2 Kubernetes的自愈能力 281
12.2.1 容器故障 282
12.2.2 節點故障 282
12.2.3 系統故障 283
12.3 Kubernetes集群自動伸縮 284
12.3.1 Pod水平自動伸縮 284
12.3.2 集群自動伸縮 286
12.3.3 Pod垂直自動伸縮 287
12.4 使用Kubernetes供應資源 289
12.4.1 應該提供哪些資源 289
12.4.2 定義容器限制 289
12.4.3 資源配額 290
12.4.4 手動供應 291
12.4.5 利用自動伸縮 292
12.4.6 自定義自動供應 292
12.5 正確地優化性能 292
12.5.1 性能和用戶體驗 292
12.5.2 性能和高可用性 293
12.5.3 性能和成本 293
12.5.4 性能和安全性 293
12.6 日誌 294
12.6.1 日誌應該記錄什麼 294
12.6.2 日誌與錯誤報告 294
12.6.3 Go日誌接口 294
12.6.4 使用Go-kit日誌 295
12.6.5 使用Kubernetes集中管理日誌 298
12.7 在Kubernetes上收集指標 299
12.7.1 Kubernetes指標API 300
12.7.2 Kubernetes指標服務器 301
12.7.3 使用Prometheus 302
12.8 警報 308
12.8.1 擁抱組件故障 309
12.8.2 接受系統故障 309
12.8.3 考慮人為因素 309
12.8.4 使用Prometheus警報管理器 310
12.9 分佈式跟踪 312
12.9.1 安裝Jaeger 312
12.9.2 將跟踪集成到服務中 313
12.10 小結 315
12.11 擴展閱讀 315

13章 服務網格與Istio 317
13.1 技術需求 317
13.2 服務網格 318
13.2.1 單體架構與微服務架構 319
13.2.2 使用共享庫管理微服務的橫切關注點 319
13.2.3 使用服務網格管理微服務的橫切關注點 320
13.2.4 理解Kubernetes與服務網格之間的關係 320
13.3 Istio 321
13.3.1 了解Istio架構 321
13.3.2 使用Istio管理流量 324
13.3.3 使用Istio保護集群 328
13.3.4 使用Istio實施策略 331
13.3.5 使用Istio收集指標 331
13.3.6 什麼時候應該避免使用Istio 332
13.4 基於Istio構建Delinkcious 333
13.4.1 簡化服務間的認證 333
13.4.2 優化金絲雀部署 335
13.4.3 自動化的日誌管理和錯誤報告 336
13.4.4 兼容NATS 338
13.4.5 查看Istio足跡 338
13.5 Istio的替代方案 341
13.5.1 Linkerd 2.0 341
13.5.2 Envoy 341
13.5.3 HashiCorp Consul 341
13.5.4 AWS App Mesh 342
13.5.5 其他 342
13.5.6 不使用服務網格 342
13.6 小結 342
13.7 擴展閱讀 343

14章 微服務和Kubernetes的未來 344
14.1 微服務的未來 345
14.1.1 微服務與無服務器函數 345
14.1.2 微服務、容器和編排 345
14.1.3 gRPC和gRPC-Web 346
14.1.4 GraphQL 346
14.1.5 HTTP/3 346
14.2 Kubernetes的未來 347
14.2.1 Kubernetes的可擴展性 348
14.2.2 服務網格集成 349
14.2.3 Kubernetes上的無服務器計算 350
14.2.4 Kubernetes和VM 351
14.2.5 集群自動伸縮 352
14.2.6 使用Operator 353
14.2.7 集群聯邦 354
14.3 小結 355
14.4 擴展閱讀 355
```
